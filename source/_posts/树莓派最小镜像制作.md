---
title: 树莓派最小镜像制作
date: 2021-11-22 17:27:00
tags: 
- 树莓派
- 工具
---

最近有个项目用到树莓派，需要对系统进行备份和复制。</br>
之前同事使用的方案是直接将整个树莓派的SD卡生成镜像的方式，不过这个方式生成的镜像是跟SD卡一样大的，如果用64G的卡就会生成64G的镜像，无论实际的系统文件的占用大小是多少，非常浪费空间和时间。</br>
尝试了很多方法后最后找到[kevin大佬](https://github.com/nanhantianyi)的[树莓派系统最小镜像备份](https://github.com/nanhantianyi/rpi-backup)脚本,完美解决了问题，在ubuntu20.04 mate版本的系统上成功备份，非常牛逼。</br>
这篇博客主要用于记录最小镜像的制作方法以及对制作脚本的分析理解。</br>

<!-- more -->

# 树莓派系统复制
在最开始先介绍一种最粗暴的树莓派系统复制方法，就是直接将树莓派SD卡复制到新的SD卡上，适合需求数量少并且比较紧急的时候。不过需要注意新的SD卡需要跟系统卡是同一批次的（或者容量更大），因为不同批次的SD卡容量可能有差别，会导致系统复制失败。</br>

将新的SD卡通过读卡器插在树莓派的USB口上，然后执行以下指令。

```
$ dd bs=4M if=/dev/mmcblk0 of=/dev/sda
```

命令中的/dev/mmcblk0就是树莓派上原本的储存卡，/dev/sda为外界的储存设备（可能会随着接入的设备多少而改变，如可能为sdb，sdc等，自己根据情况去判断是哪一个）。</br>
执行命令后终端不会有任何信息弹出，此时不要做任何操作，等待系统烧录完成即可。

# 树莓派最小系统镜像制作
最小镜像制作的操作非常简单，首先下载系统备份脚本,然后直接运行备份脚本即可：
```
$ git clone git@github.com:nanhantianyi/rpi-backup.git
$ cd rpi_backup_master
$ sudo bash back.sh path/xxx.img
```
“path/xxx.img”为备份的文件路径和名称。

系统恢复后执行resize.sh脚本对root分析扩容。

```
$ sudo bash resize.sh
```

## 注意事项

1. 备份镜像大小计算：(boot分区全部 + root分区已使用) * 1.2

2. 如果sd卡剩余空间充足，可以备份到卡内，如果剩余空间有限，请备份到外部设备

3. 如果需要备份到外部设备，设备务必挂载到/media,不要挂载到/mnt,因为创建的镜像会挂载到/mnt进行操作

# 脚本代码分析
## back.sh

```shell
#!/bin/bash

if [ `whoami` != "root" ];then              #判断用户是否为root
    echo "This script must be run as root!"
    exit 1
fi

# install software                          #安装需要的工具
apt update
apt install -y dosfstools parted kpartx rsync

echo ""
echo "software is ready"

file="rpi-`date +%Y%m%d%H%M%S`.img"         #默认镜像名称为rpi+时间戳

if [ "x$1" != "x" ];then                    #判断参数是否为空
    file="$1"                               #如果参数不为空，文件名为参数
fi

# boot mount point
boot_mnt=`findmnt -n /dev/mmcblk0p1 | awk '{print $1}'` #/dev/mmcblk0p1是树莓派的boot目录，通过awk命令将‘findmnt -n /dev/mmcblk0p1’的第一个值分割出来

root_info=`df -PT / | tail -n 1`            #运行“df -PT /”，获取输出的第一行

root_type=`echo $root_info | awk '{print $2}'`    #获取“root_info”的第二个数据，即文件系统类型

dr=`echo $root_info | awk '{print $4}'`           #获取使用了的空间大小
db=`df -P | grep /dev/mmcblk0p1 | awk '{print $2}'`   #获取boot分区的使用空间大小
ds=`echo $dr $db |awk '{print int(($1+$2)*1.2)}'`     #获取根分区+boot分区的使用大小并乘1.2

echo "create $file ..."

dd if=/dev/zero of=$file bs=1K count=0 seek=$ds  #创建空的镜像文件
#truncate -s ${ds}k $file

start=`fdisk -l /dev/mmcblk0| awk 'NR==9 {print $2}'`  
end=`fdisk -l /dev/mmcblk0| awk 'NR==9 {print $3}'`

if [ "$start" == "*" ];then
    start=`fdisk -l /dev/mmcblk0| awk 'NR==9 {print $3}'`
    end=`fdisk -l /dev/mmcblk0| awk 'NR==9 {print $4}'`
fi

start=`echo $start's'`
end=`echo $end's'`

end2=`fdisk -l /dev/mmcblk0| awk 'NR==10 {print $2}'`
end2=`echo $end2's'`

echo "start=$start"
echo "end=$end"
echo "end2=$end2"

parted $file --script -- mklabel msdos    #创建分区表，msdos是MBR
parted $file --script -- mkpart primary fat32 $start $end   #创建新分区，分区类型为主分区，文件系统类型为fat32，并指定了分区的起始和结束位置
parted $file --script -- mkpart primary ext4 $end2 -1       #创建新分区，分区类型为主分区，文件系统类型为ext4，并指定分区起点为end2，结束位置为镜像的结束位置

loopdevice=`losetup -f --show $file`      #挂载空镜像
device=`kpartx -va $loopdevice | sed -E 's/.*(loop[0-9])p.*/\1/g' | head -1`    #挂载循环设备，执行“sed -E 's/.*(loop[0-9])p.*/\1/g'”后获取第一行
device="/dev/mapper/${device}"   

echo "device=$device"

partBoot="${device}p1"         #设置boot分区的名称
partRoot="${device}p2"         #设置root分区的名称

echo "partBoot=$partBoot"
echo "partRoot=$partRoot"

sleep 5s

opartuuidb=`blkid -o export /dev/mmcblk0p1 | grep PARTUUID`
opartuuidr=`blkid -o export /dev/mmcblk0p2 | grep PARTUUID`

npartuuidb=`blkid -o export ${partBoot} | grep PARTUUID`
npartuuidr=`blkid -o export ${partRoot} | grep PARTUUID`

boot_label=`dosfslabel /dev/mmcblk0p1 | tail -n 1`
root_label=`e2label /dev/mmcblk0p2 | tail -n 1`

mkfs.vfat -F 32 -n "$boot_label" $partBoot
echo "$partBoot format success"

mkfs.ext4 $partRoot
e2label $partRoot $root_label
echo "$partRoot format success"

mount -t vfat $partBoot /mnt
cp -rfp ${boot_mnt}/* /mnt/

sed -i "s/$opartuuidr/$npartuuidr/g" /mnt/cmdline.txt

sync

umount /mnt

mount -t ext4 $partRoot /mnt

if [ -f /etc/dphys-swapfile ]; then
    SWAPFILE=`cat /etc/dphys-swapfile | grep ^CONF_SWAPFILE | cut -f 2 -d=`
    if [ "$SWAPFILE" = "" ]; then
        SWAPFILE=/var/swap
    fi
    EXCLUDE_SWAPFILE="--exclude $SWAPFILE"
fi

cd /mnt

rsync --force -rltWDEgop --delete --stats --progress \
    $EXCLUDE_SWAPFILE \
    --exclude ".gvfs" \
    --exclude "$boot_mnt" \
    --exclude "/dev" \
    --exclude "/media" \
    --exclude "/mnt" \
    --exclude "/proc" \
    --exclude "/run" \
    --exclude "/snap" \
    --exclude "/sys" \
    --exclude "/tmp" \
    --exclude "lost\+found" \
    --exclude "$file" \
    / ./

if [ ! -d $boot_mnt ]; then
    mkdir $boot_mnt
fi

if [ -d /snap ]; then
    mkdir /mnt/snap
fi

for i in boot dev media mnt proc run sys boot; do
    if [ ! -d /mnt/$i ]; then
        mkdir /mnt/$i
    fi
done

if [ ! -d /mnt/tmp ]; then
    mkdir /mnt/tmp
    chmod a+w /mnt/tmp
fi

cd

sed -i "s/$opartuuidb/$npartuuidb/g" /mnt/etc/fstab
sed -i "s/$opartuuidr/$npartuuidr/g" /mnt/etc/fstab

sync

umount /mnt                

kpartx -d $loopdevice      #卸载循环设备
losetup -d $loopdevice     #卸载循环设备

```


## resize.sh
```shell
#!/bin/bash
FSTYPE=$(cat /proc/cmdline |tr ' ' '\n' | awk -F= '/rootfstype/{print $2}')
BLKDEV_ROOTPART=$(findmnt / -o SOURCE -n)
ROOTPART_SEQ=$(echo $BLKDEV_ROOTPART | grep -o "[0-9]$")
BLKDEV_ROOTPART_NAME=$(echo $BLKDEV_ROOTPART | cut -d "/" -f 3)
BLKDEV=/dev/$(find /sys/block/*/ | grep $BLKDEV_ROOTPART_NAME$ | cut -d "/" -f 4)
RESIZE_TARGET=$BLKDEV_ROOTPART

if [ ! $RESIZER ]; then
    case $FSTYPE in
        f2fs)
            RESIZER=$(which resize.f2fs)
            ;;
        ext2|ext3|ext4)
            RESIZER=$(which resize2fs)
            ;;
        btrfs)
            RESIZER=$(which btrfs)
            RESIZER_ARGS="filesystem resize max"
            RESIZE_TARGET="/"
            mount -o remount,rw $RESIZE_TARGET
            ;;
        *)
            RESIZER=$(which resize.$FSTYPE)
            echo "FSTYPE is $FSTYPE, RESIZER could be $RESIZER"
            ;;
    esac
    if [ ! -e $RESIZER ]; then
        echo "Filesystem resizer for $FSTYPE not found!"
        exit 1
    fi
fi

echo "Resizing partiton..."
parted -s $BLKDEV -- resizepart $ROOTPART_SEQ 100%

echo "Informing kernel..."
# Make sure we have updated partition info
partx -u $BLKDEV
partx -u $BLKDEV_ROOTPART
partprobe $BLKDEV
partprobe $BLKDEV_ROOTPART

echo "Resizing filesystem..."
$RESIZER $RESIZER_ARGS $RESIZE_TARGET

systemctl daemon-reload 2>/dev/null
ldconfig 2>/dev/null

echo "Syncing to disk..."
sync && sync

echo ''
echo "Rebooting in 5 seconds..."
a=5
for i in $(seq 1 5); do
echo $a
sleep 1
a=$((a-1))
done

echo "Rebooting..."
init 6
```